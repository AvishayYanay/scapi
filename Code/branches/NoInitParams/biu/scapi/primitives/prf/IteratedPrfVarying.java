package edu.biu.scapi.primitives.prf;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.InvalidParameterSpecException;
import java.util.logging.Level;

import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.spec.SecretKeySpec;

import edu.biu.scapi.exceptions.FactoriesException;
import edu.biu.scapi.generals.Logging;
import edu.biu.scapi.primitives.prf.bc.BcHMAC;
import edu.biu.scapi.tools.Factories.PrfFactory;

/** 
 * This class is one implementation of pseudorandom function with varying IO, based on any prf with varying input length. <p>
 * The implementation is based on several calles to the prf-based and concatenation of the results.
 * 
 * @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Meital Levy)
 */
public class IteratedPrfVarying extends PrfVaryingFromPrfVaryingInput {
	
	private SecureRandom random;
	
	/**
	 * Default constructor that uses HMac.
	 * @throws FactoriesException 
	 */
	public IteratedPrfVarying() throws FactoriesException{
		this(new BcHMAC(), new SecureRandom());
	}
	/** 
	 * Constructor that accepts the name of the underlying prfVaryingInputLength.
	 * @param prfVaryingInputName  the prf to use. 
	 * @throws FactoriesException 
	 */
	public IteratedPrfVarying(String prfVaringInputName) throws FactoriesException {
		
		//get the requested prfVaringInput from the factory, creates random and call the extended constructor 
		this((PrfVaryingInputLength) PrfFactory.getInstance().getObject(prfVaringInputName), new SecureRandom());
	}
	
	/** 
	 * Constructor that accepts the name of the underlying prfVaryingInputLength.
	 * @param prfVaryingInputName  the prf to use. 
	 * @throws FactoriesException 
	 * @throws NoSuchAlgorithmException 
	 */
	public IteratedPrfVarying(String prfVaringInputName, String randNumGenAlg) throws FactoriesException, NoSuchAlgorithmException {
		
		//get the requested prfVaringInput and random from the factories. 
		//then call the extended constructor
		this((PrfVaryingInputLength) PrfFactory.getInstance().getObject(prfVaringInputName), SecureRandom.getInstance(randNumGenAlg));
	}
	
	/**
	 * Constructor that accepts the underlying PrfVaryingInputLength.
	 * @param prfVaryingInput the underlying prf varying. MUST be initialized, and there is no need to call init.
	 */
	public IteratedPrfVarying(PrfVaryingInputLength prfVaryingInput){
		//creates random and call the extended constructor
		this(prfVaryingInput, new SecureRandom());
	}
	
	/**
	 * Constructor that accepts the underlying PrfVaryingInputLength and random to use.
	 * @param prfVaryingInput the underlying prf varying. MUST be initialized, and there is no need to call init.
	 * @param random SecureRandom object to use
	 */
	public IteratedPrfVarying(PrfVaryingInputLength prfVaryingInput, SecureRandom random){
		
		//assigns the prf varying input.
		prfVaryingInputLength = prfVaryingInput;
		this.random = random;
	}

	/** 
	 * @return the algorithm name - SC_PRF_VARY_INOUT.
	 */
	public String getAlgorithmName() {
		
		return "ITERATED_PRF_VARY_INOUT";
	}

	/** 
	 * Not relevant - the input and the output do not have a fixed size.
	 * @throws IllegalStateException
	 */
	public int getBlockSize() {
		
		throw new IllegalStateException("prp varying has no fixed block size");
	}

	/**
	 * Generates a secret key to initialize this prf object.
	 * @param keySize algorithmParameterSpec contains the required secret key size in bits 
	 * @return the generated secret key
	 * @throws InvalidParameterSpecException 
	 */
	public SecretKey generateKey(AlgorithmParameterSpec keyParams) throws InvalidParameterSpecException{
		throw new UnsupportedOperationException("To generate a key for this HMAC object use the generateKey(int keySize) function");
	}
	
	/**
	 * Generates a secret key to initialize this prf object.
	 * @param keySize is the required secret key size in bits 
	 * @return the generated secret key 
	 */
	public SecretKey generateKey(int keySize){
		//generate a random string of bits of length keySize, which has to be greater that zero. 
		
		//if the key size is zero or less - throw exception
		if (keySize < 0){
			throw new NegativeArraySizeException("key size must be greater than 0");
		}
		//creates a byte array of size keySize
		byte[] genBytes = new byte[keySize];

		//generates the bytes using the random
		//Do we need to seed random??
		random.nextBytes(genBytes);
		//creates a secretKey from the generated bytes
		SecretKey generatedKey = new SecretKeySpec(genBytes, "");
		
		return generatedKey;
		
	}
	
	/**
	 * Computes the iterated permutation. <p>
	 * 
	 * The algorithm pseudocode is:
	 * 
	 * outlen = outBytes.length
	 *	x = inBytes
	 *	----------------
	 *	Let m be the smallest integer for which L*m > outlen, where L is the output length of the PrfVaryingInputLength. 
	 *	FOR i = 1 to m 
	 *	compute Yi = PrfVaryingInputLength(k,(x,outlen,i)) [key=k, data=(x,outlen,i)] 
	 *	return the first outlen bits of Y1,…,Ym  
	 * 
	 * This function is necessary since this prf has variable input and output length.
	 * @param inBytes - input bytes to compute
	 * @param inLen - the length of the input array
	 * @param inOff - input offset in the inBytes array
	 * @param outBytes - output bytes. The resulted bytes of compute.
	 * @param outOff - output offset in the outBytes array to put the result from
	 * @param outLen - the length of the output array
	 */
	public void computeBlock(byte[] inBytes, int inOff, int inLen, 
			byte[] outBytes, int outOff, int outLen) {
		if (!isKeySet()){
			throw new IllegalStateException("secret key isn't set");
		}
		// checks that the offset and length are correct 
		if ((inOff > inBytes.length) || (inOff+inLen > inBytes.length)){
			throw new ArrayIndexOutOfBoundsException("wrong offset for the given input buffer");
		}
		if ((outOff > outBytes.length) || (outOff+outLen > outBytes.length)){
			throw new ArrayIndexOutOfBoundsException("wrong offset for the given output buffer");
		}
		int prfLength = prfVaryingInputLength.getBlockSize();            //the output size of the prfVaryingInputLength
		int rounds = (int) Math.ceil((float)outLen / (float)prfLength);  //the smallest integer for which rounds * prfLength > outlen
		byte[] intermediateOutBytes = new byte[prfLength];               //round result
		byte[] currentInBytes = new byte[inLen+2];                       //the data for the prf 
		
		Integer outLenByte = new Integer(outLen);
		
		//copies the x (inBytes) to the input of the prf in the beginning
		System.arraycopy(inBytes, inOff, currentInBytes, 0, inLen);
		//copies the outLen to the input of the prf after the x
		currentInBytes[inLen] = outLenByte.byteValue();
		
		Integer round;
		
		for(int i=1; i<=rounds; i++) {
			
			round = new Integer(i);
			
			//copies the i to the input of the prf
			currentInBytes[inLen+1] = round.byteValue();
			
			//operates the computeBlock of the prf to get the round output
			try {
				prfVaryingInputLength.computeBlock(currentInBytes, 0, currentInBytes.length, intermediateOutBytes, 0);
			} catch (IllegalBlockSizeException e) {
				Logging.getLogger().log(Level.WARNING, e.toString());
			}
			
			
			if (i==rounds) { //copies the round result to the output byte array
				//in case of the last round - copies only the number of bytes left to match outLen
				System.arraycopy(intermediateOutBytes, 0, outBytes, outOff+(i - 1)*prfLength, outLen-((i-1)*prfLength));
			} else { //in other cases - copies all the result bytes
				System.arraycopy(intermediateOutBytes, 0, outBytes, outOff+(i-1)*prfLength, prfLength);
			}
		}
	}

	
}