/**
 * 
 */
package edu.biu.scapi.interactiveMidProtocols.commitmentScheme.equivocal;

import java.io.IOException;

import edu.biu.scapi.comm.Channel;
import edu.biu.scapi.exceptions.CheatAttemptException;
import edu.biu.scapi.exceptions.CommitValueException;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtReceiver;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtWithProofsReceiver;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtCommitValue;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.CmtRCommitPhaseOutput;
import edu.biu.scapi.interactiveMidProtocols.commitmentScheme.pedersen.CmtPedersenWithProofsReceiver;
import edu.biu.scapi.securityLevel.EquivocalCT;

/**
 * Concrete implementation of Equivocal commitment scheme in the receiver's point of view.
 * This is a protocol to obtain an equivocal commitment from any commitment with a ZK-protocol 
 * of the commitment value.
 * The equivocality property means that a simulator can decommit to any value it needs 
 * (needed for proofs of security).
 * 
 * @author Cryptography and Computer Security Research Group Department of Computer Science Bar-Ilan University (Moriya Farbstein)
 *
 */
public class CmtEquivocalReceiver implements CmtReceiver, EquivocalCT {
	
	/*
	  Runs the following pseudo code:
	  	Commit phase
			RUN any COMMIT protocol for C to commit to x
		Decommit phase, using ZK protocol of decommitment value
			Run ZK protocol as the verifier, that x is the correct decommitment value
			IF verifier-output of ZK is ACC
		          OUTPUT ACC and x
		    ELSE
		          OUTPUT REJ

	 */
	
	protected CmtWithProofsReceiver receiver;
	
	/**
	 * Constructor that gets the receiver to use in the protocol execution.
	 * @param receiver
	 */
	public CmtEquivocalReceiver(CmtWithProofsReceiver receiver){
		this.receiver = receiver;
	}
	
	/**
	 * Constructor that gets channel to use in the protocol execution and chooses default receiver.
	 * @param channel
	 * @throws CheatAttemptException 
	 * @throws IOException 
	 * @throws ClassNotFoundException 
	 */
	public CmtEquivocalReceiver(Channel channel) throws ClassNotFoundException, IOException, CheatAttemptException{
		receiver = new CmtPedersenWithProofsReceiver(channel);
	}
	
	/**
	 * Runs the following line of the protocol:
	 * "RUN any COMMIT protocol for C to commit to x".
	 */
	public CmtRCommitPhaseOutput receiveCommitment() throws ClassNotFoundException, IOException {
		//Delegate to the underlying receiver.
		return receiver.receiveCommitment();
	}

	/**
	 * Runs the following lines of the protocol:
	 * "Run ZK protocol as the verifier, that x is the correct decommitment value
	 *		IF verifier-output of ZK is ACC
	 *          OUTPUT ACC and x
	 *    	ELSE
	 *          OUTPUT REJ".
	 * @throws CommitValueException 
	 * @throws CheatAttemptException 
	 * @throws ClassNotFoundException 
	 * @throws IOException 
	 */
	public CmtCommitValue receiveDecommitment(long id) throws IOException, ClassNotFoundException, CheatAttemptException, CommitValueException {
		//During the execution of verifyCommittedValue, the x is received by the receiver.
		return receiver.verifyCommittedValue(id);
	}

	@Override
	public Object[] getPreProcessedValues() {
		//Delegate to the underlying receiver.
		return receiver.getPreProcessedValues();
	}

	@Override
	public Object getCommitmentPhaseValues(long id) {
		//Delegate to the underlying receiver.
		return receiver.getCommitmentPhaseValues(id);
	}
	
	/**
	 * This function converts the given commit value to a byte array. 
	 * @param value
	 * @return the generated bytes.
	 */
	public byte[] generateBytesFromCommitValue(CmtCommitValue value){
		//Delegate to the underlying receiver.
		return receiver.generateBytesFromCommitValue(value);
	}
}